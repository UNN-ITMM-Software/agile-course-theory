# Лабораторная работа #2: Model-View-ViewModel

## Цели

  1. Ознакомиться в паттернами организации GUI на примере MVVM.
  1. Освоить практику реализации логики взаимодействия с пользователем согласно
     TDD подходу. Как следствие, получить покрытие тестами презентационной
     логики.

## Задачи

  1. Расширить свой Java-проект до трех сборок: `Model`, `View` и `ViewModel`.
     - Первый компонент фактически уже реализован, нужно будет только обновить
       build-скрипты.
     - Сборка `ViewModel` должна представлять собой отдельный Java-проект,
       ответственностью которого является реализация логики взаимодействия с
       пользователем (обработка ввода, вывод результатов). Разработка
       `ViewModel` должна вестись согласно практике TDD.
     - Сборка `View` также представляет собой отдельный Java-проект, основной
       частью которого является графическая форма. Предполагается, что форма
       спроектирована и реализована в среде Scene Builder на основе платформы JavaFX.
  1. Поскольку проект будет состоять из нескольких сборок, нужно соответствующим
     образом обновить сборочные скрипты Gradle. Они должны допускать импорт
     проекта в IntelliJ IDEA, а также сборку и тестирование в Travis CI.
  1. Как и в прошлый раз, особое внимание нужно обратить на тщательное
     автоматическое тестирование. При нехватке или плохом качестве тестов будет
     требоваться доработка. Результаты работы следует присылать в виде пулл-
     реквеста, и добиться прохождения всех проверок в системе непрерывной
     интеграции Travis CI.

## Типичные ошибки

TBD

## Инструкции

### Установка JavaFX & Scene Builder

Для поддержки JavaFX необходимо обновить версию JDK до 8. Сделать это можно следующим образом:

Для Windows:
 - Скачать и установить дистрибутив с [сайта][jdk8] Oracle.
 - Добавить в "Переменные среды" cистемную переменную `JAVA_HOME` и указать
   в ней путь к каталогу с JDK8, например `C:\Program Files\Java\jdk1.8.0_25`.

Для Ubuntu:
 - Выполнить в терминале: `sudo apt-get install oracle-java8-set-default`,
   подробнее на [linuxrussia][installJavaUbuntu].

В среде IntelliJ IDEA необходимо выбрать новую версию JDK:
 - Открыть вкладку Project: `File->Project Structure->Project`,
 - Добавить новый SDK: `New-><выбрать путь до установленного JDK8>`.

Для проектирования графического интерфейса c JavaFX, надо дополнительно установить [Scene Builder][sceneBuilder].

### Предварительная работа

Данная лабораторная работа потребует более серьезных усилий, поэтому сперва
необходимо убедиться, что все окружение настроено правильно.

  1. Первым делом стоит получить последние коды из репозитория (стоит делать
     это всякий раз перед началом выполнения лабораторной работы).

        $ cd agile-course-practice
        $ git fetch upstream
        $ git checkout master
        $ git rebase upstream/master
        $ git checkout -b lab2-mvvm-SOMETHING

  1. После этого стоит убедиться, что все компилируется и работает:

        $ gradle check

  1. Все личные проекты должны собраться и запуститься тесты. Стоит обратить
     внимание на папку с примером `kornyakov-kirill-lab2`, в которой находится
     требуемая структура проекта, в том числе модуль `ViewModel` и тесты на
     него.
  1. Затем стоит сгенерировать проект для IDEA, и открыть его. Внимание: этот
     шаг возможно уничтожит ваш собственный проект IDEA (папка `.idea`), но он
     вам и не нужен.

        $ gradle clean cleanIdea cleanIdeaWorkspace
        $ gradle idea

  1. Теперь можно запустить IDEA и открыть проект, который был сгенерирован
     Gradle в директории `agile-course-practice` (файл `code.ipr`).
     __Внимание__: нужно именно генерировать проект и после открывать (не
     импортировать!) его в IDEA. Теоретически, IDEA должна сама прожевывать
     Gradle-скрипты, но почему-то у нее это получается не до конца.
  1. Все что осталось — это убедиться, что из IDEA вы можете запускать тесты и
     GUI-приложение. Для этого в браузере проекта (левая часть окна IDEA)
     найдите папку `kornyakov-kirill-lab2` и раскройте ее. Там будет 3
     подпроекта.
     - На проектах `Model` и `ViewModel` можно нажать правую кнопку мыши и
       выбрать команду `Run 'All Tests'`. В обоих случаях все тесты должны
       успешно пройти.
     - В проекте `View` нужно полностью раскрыть папку `src` и найти класс
       `Main`. На нем можно нажать правую кнопку и выбрать пункт
       `Run 'Main.main()'`. Запустится форма, представляющая собой
       калькулятор комплексных чисел. Форма примитивная, но нам ее будет
       достаточно.

Собственно на этом все, теперь вашей задачей является достижение аналогичного
состояния в своей личной папке.

### Реализация

#### Общий алгоритм

Предполагается, что слой `Model` у вас уже готова. Там содержится главный
класс и тесты на него. Мы, таким образом сосредоточимся на реализации паттерна
MVVM.

  1. Создать новый проект `View` и спроектировать в нем GUI, используя
     технологию JavaFX и дизайнер Scene Builder. На этом этапе не нужно привязывать
     форму к вашим классам.
  1. Создать новый проект `ViewModel`, являющийся моделью созданного выше GUI.
     Его разработка должна вестись по TDD.
  1. Вернуться к `View`, сделать так, чтобы класс использовал `ViewModel`,
     настроить соответствующим образом привязку графических компонентов к полям
     класса.

#### Детальные инструкции

##### View

Первым делом предлагается сверстать графическую форму в IDEA. Мы делаем это
вперед `ViewModel` только затем, чтобы продумать интерфейс и логику
взаимодействия с пользователем. Чтобы создать пустой проект, необходимо
выполнить следующие шаги:

  1. Создать директорию `View` в своей подпапке.
  1. Создать набор вложенных директорий для исходников, подобно тому, как это
     сделано в вашей `Model` и проекте-примере:
     `code/kornyakov-kirill-lab2/View/src/main/java/ru/unn/agile/ComplexNumber/view/`.
  1. Положить в вашу папку `View` файл `build.gradle` следующего содержания:

        apply from:   rootDir.getAbsolutePath() + '/code/config/scripts/javafx.plugin'

        dependencies {
            compile project(':kornyakov-kirill-lab2-ViewModel')
        }

        sourceSets {
            main.java.srcDir 'src/main/java'
            test.java.srcDir 'src/test/java'
        }

  1. Затем необходимо добавить этот файл в общий проект. Снова идем в
     глобальный `settings.gradle` и добавляем две строки в вашей
     секции "регистрирующие" директорию `View` и соответствующий ей проект.
  1. Теперь можно сгенерировать проект для IDEA, чтобы открыть его и
     приступить к проектированию формы. Выполняем следующую команду в консоли:

        $ cd agile-course-practice
        $ gradle kornyakov-kirill-lab2-View:idea # change the project name to yours

  1. Сгенерированный проект можно снова открыть в IDEA. Либо, если IDEA
     оставалась открытой, среда сама заметит изменения в файлах проекта и
     предложит перезагрузить проект. Нужно просто согласиться. Как результат,
     вы должны увидеть в своей папке уже два подпроекта: `Model` и `View`.
  1. Теперь следует добавить пустую форму:
     - В проекте `View` внутри папки `src` создайте папку `resources`, внутри которой воссоздайте используемую структуру папок для классов (в проекте-примере это `ru/unn/agile/ComplexNumber/view`). По аналогии с примером, добавьте `Main.java`, `<Insert-your-project-name>.java` внутрь `src/main/java/...`, FXML файл с разметкой в `src/main/resources/...`. Можно воспользоваться шаблоном разметки:

     ```
     <?xml version="1.0" encoding="UTF-8"?>

     <?import javafx.scene.layout.*?>
     <AnchorPane xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="ru.unn.agile.ComplexNumber.view.Calculator">
     </AnchorPane>
     ```
     где в `id` контроллера укажите полное имя своего класса. После этого файл разметки можно будет открыть в Scene Builder из IDEA (ПКМ на FXML файле->Open In SceneBuilder) или запустить Scene Builder самостоятельно и открыть в нем нужный файл.

  1. Процесс дизайна формы с JavaFX интуитивно понятен, несколько статей:
     - [Using Scene Builder with IntelliJ IDEA][sbWithIDEA],
     - [FXML: Why It Rocks, And The Next Phase][fxmlRocks],
     - [JavaFX GUI development: FXML vs Java code][javafxGui].
  1. Чтобы запустить форму, нажмите правой клавишей мыши по классу `Main` и выберите "Run Main.main".
  1. Таким образом, предстоит сверстать форму, которая позволяла бы
     пользоваться вашим классом. Саму привязку класса делать не нужно,
     следует лишь зарезервировать поля.
  1. Результаты своей работы следует зафиксировать очередным коммитом в Git.
     Также можно сделать `git push` в свой репозиторий на GitHub, чтобы Travis
     снова прогнал тесты.

##### ViewModel

Далее следует приступить к реализации `ViewModel`. По своей сути этот класс
является моделью вашей графической формы (что собственно следует из названия).
Таким образом, в нем следует завести поля, соответствующие графическим элементам
на вашем интерфейсе. Так, текстовые поля и метки отобразятся в обычные строки,
выпадающие списки можно "перевести" в поле типа `enum`. А нажатие на кнопку
можно обрабатывать как вызов обычного метода `ViewModel`.

Далее рассмотрим процесс реализации `ViewModel` по шагам:

  1. Аналогично тому, как создавались подпапки `Model` и `View`, нужно создать
     директорию `ViewModel`.
  1. В ней снова следует создать вложенную структуру папок для Java-исходников и
     тестов, полностью аналогично тому, как это сделано в директории `Model`.
     Единственное отличие, что имя Java пакета должно быть `viewmodel`, то
     есть полное имя выглядит примерно следующим образом:
     `package ru.unn.agile.ComplexNumber.viewmodel;`.
  1. Затем следует создать `build.gradle` файл, и положить его в корень вашей
     директории `ViewModel`. Этот файл должен указывать системе сборки на
     исходники ваших классов и тестов, плюс указывать зависимость от вашего
     проекта `Model`. Вот примерный вид `build.gradle` файла:

        dependencies {
            compile project(':kornyakov-kirill-lab2-Model')
        }

        sourceSets {
            main.java.srcDir 'src/main/java'
            test.java.srcDir 'src/test/java'
        }

  1. Следующим шагом следует добавить созданный подпроект в систему сборки. Для
     этого снова открываем общий `settings.gradle` файл добавлем еще две строки
     в вашей секции. Как результат, вы теперь можете сгенерировать проект IDEA:

        $ cd agile-course-practice
        $ gradle kornyakov-kirill-lab2-ViewModel:idea

  1. Теперь можно открыть проект в IDEA и начать разработку согласно TDD
     практике. Стоит завести во `ViewModel` строковые поля, соответствующие
     входным агрументам, и метке статуса. Первым тестом может быть проверка на
     то, что выводятся корректные значения по умолчанию (например пустые строки
     для входных аргументов). Затем можно проверить (написать тест и реализовать
     код) при некорректном вводе от пользователя (например пустой ввод),
     выводится сообщение об ошибке.
  1. После этого уже можно переходить к полноценной реализации логики
     взаимодействия с пользователем. Пишутся тесты на все типичные сценарии
     взаимодействия, после чего эта логика реализуется по `ViewModel`. Стоит
     обратить особое внимание на то, что на этом этапе нет никакой необходимости
     использовать вашу реальную `View`.
  1. В качестве отдельного упражнения можно реализовать логику
     активации/деактивации контролов в зависимости от того, является ли
     корректным ввод. За инструкциями следует обратиться к проекту-примеру.
  1. Когда разработка `ViewModel` будет закончена, стоит убедиться, что все
     созданные тесты успешно проходят (`gradle kornyakov-kirill-lab2-ViewModel:check`).
     Как обычно, рекомендуется сделать коммит и послать коды на тестирование Travis.

##### View

Последним шагом следует связать `View` и `ViewModel`. Сделать это относительно
просто:

  1. Первым делом нужно добавить зависимость `View` от `ViewModel`. Для этого
     открываем `build.gradle` в вашей директории `View` и добавляем информацию
     про зависимость:

        dependencies {
            compile project(':kornyakov-kirill-lab2-ViewModel')
        }

        sourceSets {
            main.java.srcDir 'src/main/java'
        }

  1. Затем перегенерируем IDEA проект (`gradle kornyakov-kirill-lab2-View:idea`) и
     снова открываем его в IDE.
  1. Далее следует завести поле типа `ViewModel` в вашем классе формы.
  1. Последнее что осталось сделать - это осуществить привязку полей реальной
     формы и ее модели, то есть `View` и `ViewModel`.

     - JavaFX поддерживает автоматическое связывание моделей с View. View содержит различные элементы управления (`Button`, `TextField`, ...), информация в которые (или из которых) поступает в модель для обработки. Чтобы соединить данные в модели и View необходимо создать свойство (property) в модели и связать его с свойством объекта View. В качестве примера рассмотрим класс `Label` - элемент управления с нередактируемым текстовым полем. У него есть свойство `text`, в которое выводится :open_mouth: текст. В проекте-примере ViewModel подсчитывает результат арифметического действия и выводит его в текстовое поле лейбла. Для связи результата вычислений и текста в лейбле, создаем в ViewModel свойство `StringProperty result`, и, после выполениня арифметической опрерации, устанавлеваем в нем текст с результатом: `result.set("5")`.
     В FXML файле разметки добавляем аттрибут с связью: `<Label text="${viewModel.result}" .../>`. Так же, чтобы JavaFX мог получить доступ из FXML к свойству в ViewModel, необходимо объявить соответствующий публичный метод в ViewModel: `get<ExactPropertyName>()`, для StringProperty `result` должен быть метод `String getResult()`. Это все, теперь текст лейбла будет автоматически обновлятся при каждом вычислении результата.

     - *Замечания.* Чтобы JavaFX нашёл нужную ViewModel для View, ее необходимо объявить в теге `define` FXML. Binding может быть "one-way" (при обновлении ViewModel, данные View обновляются автоматически) и "two-way" (данные будут так же обновляться в ViewModel при изменении из в View, актуально для `TextField`), подробнее [здесь][msdnBinding]. На настоящий момент FXML не поддерживает "two-way" binding, его нужно установить вручную (при помощи функции `bindBidirectional()`, подробнее в `Calculator.java`). Scnene Builder может не открывать FXML разметку с установленной ViewModel, чтобы это поправить удалите на время изменения View тег `define`.

## Заключение

На этом выполнение лабораторной работы заканчивается. Стоит убедиться, что
тестами покрыты все случаи использования формы (в том числе некорректный ввод).
Также стоит просмотреть весь проект, вероятно возможно его упростить и
отрефакторить какие-то части.

После этого стоит положить все изменения в Git, и сделать pull request.

<!-- LINKS -->

[jdk8]: <http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html>
[installJavaUbuntu]: <http://www.linuxrussia.com/2013/04/oracle-java-7-ubuntu-1304-1204-1210.html>
[sceneBuilder]: <http://www.oracle.com/technetwork/java/javase/downloads/sb2download-2177776.html>
[sbWithIDEA]: <https://docs.oracle.com/javafx/scenebuilder/1/use_java_ides/sb-with-intellij.htm>
[fxmlRocks]: <http://fxexperience.com/2011/10/fxml-why-it-rocks-and-the-next-phase/>
[javafxGui]: <http://www.first8.nl/blog/javafx-gui-development-fxml-vs-java-code/>
[msdnBinding]: <http://msdn.microsoft.com/en-us/library/gg405484%28v=pandp.40%29.aspx>
