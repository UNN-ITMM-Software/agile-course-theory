# Лабораторная работа #2: Model-View-ViewModel

## Цели

  1. Ознакомиться в паттернами организации GUI на примере MVVM.
  1. Освоить практику реализации логики взаимодействия с пользователем согласно
     TDD подходу. Как следствие, получить покрытие тестами презентационной
     логики.

## Задачи

  1. Расширить свой Java-проект до трех сборок: Model, View и ViewModel.
     - Первый компонент фактически уже реализован, нужно будет только обновить
       build-скрипты.
     - Сборка ViewModel представляет собой отдельный Java-проект,
       ответственностью которого является реализация логики взаимодействия с
       пользователем (обработка ввода, вывод результатов). Разработка ViewModel
       должна вестись согласно практике TDD.
     - Сборка View также представляет собой отдельный Java-проект, основной частью
       которого является графическая форма. Предполагается, что форма
       спроектирована и реализована в среде IntelliJ IDEA на основе технологии
       Swing.
  1. Поскольку проект будет состоять из нескольких сборок, нужно соответствующим
     образом обновить сборочные скрипты Gradle. Они должны допускать импорт
     проекта в IntelliJ IDEA, а также сборку и тестирование в Travis CI.
  1. Как и в прошлый раз, особое внимание нужно обратить на тщательное
     автоматическое тестирование. При нехватке или плохом качестве тестов будет
     требоваться доработка. Результаты работы следует присылать в виде пулл-
     реквеста, и добиться прохождения всех проверок в системе непрерывной
     интеграции Travis CI.

## Типичные ошибки

TBD

## Инструкции

### Предварительная работа

Данная лабораторная работа потребует более серьезных усилий, поэтому сперва
необходимо убедиться, что все окружение настроено правильно.

  1. Первым делом стоит получить последние коды из репозитория (стоит делать
     это всякий раз перед началом выполнения лабораторной работы).
```
$ cd agile-development-course
$ git checkout master
$ git fetch upstream
$ git merge upstream/master
$ git checkout -b lab2-mvvm-SOMETHING
```
  1. После этого стоит убедиться, что все компилируется и работает:
```
$ cd ./code
$ gradle check
```
     Все личные проекты должны собраться и запуститься тесты. Стоит обратить
     внимание на папку с примером `kirill-kornyakov-lab2`, в которой находится
     уже новая структура проекта, в том числе модуль `ViewModel` и тесты на
     него.
  1. Затем стоит сгенерировать проект для IDEA, и открыть его. Внимание: этот
     шаг возможно уничтожит ваш собственный проект IDEA (папка `.idea`), но он вам
     и не нужен.
```
$ gradle clean cleanIdea cleanIdeaWorkspace
$ gradle idea
```
     Теперь можно запустить IDEA и открыть проект, который был сгенерирован
     Gradle в директории `agile-development-course/code` (файл `code.ipr`).
     Внимание: нужно именно генерировать проект и после открывать (не
     импортировать!) его в IDEA. Теоретически, IDEA должна сама прожевывать
     Gradle-скрипты, но почему-то у нее это получается не до конца.
  1. Все что осталось - это убедиться, что из IDEA вы можете запускать тесты и
     GUI-приложение. Для этого в браузере проекта (левая часть окна IDEA)
     найдите папку `kirill-kornyakov-lab2` и раскройте ее. Там будет 3
     подпроекта.
     - На проектах `Model` и `ViewModel` можно нажать правую кнопку мыши и
       выбрать команду `Run 'All Tests'`. В обоих случаях все тесты должны
       успешно пройти.
     - В проекте `View` нужно полностью раскрыть папку `src` и найти класс
       `Calculator`. На нем можно также нажать правую кнопку и выбрать пункт
       `Run 'Calculator.main()'`. Запустится форма, представляющая собой
       калькулятор комплексных чисел. Смеяться над ее кособокостью не нужно :)
       Я так и не смог добиться от дизайнера IDEA того, чего хотел :(
       Сможете вы, пожалуйста научите.

Собственно на этом все, теперь вашей задачей является достижение аналогичного
состояния в своей личной папке. Только пожалуйста обратите внимание, что от вас
потребуется раскомментировать несколько строчек в файле `code/settings.gradle`,
как это было [сделано][settings.gradle] в проекте с примером.

### Реализация

#### Общий алгоритм

  1. Переделать проект из предыдущей лабораторной так, чтобы он стал `Model` в
     новой версии.
  1. Создать новый проект `View` и спроектировать в нем GUI, используя
     технологию Swing и дизайнер из IDEA. На этом этапе не нужно привязывать
     форму к вашим классам.
  1. Создать новый проект `ViewModel`, являющийся моделью созданного выше GUI.
     Его разработка должна вестись по TDD.
  1. Вернуться к `View`, сделать так, чтобы класс формы наследовал `ViewModel`,
     настроить соответствующим образом привязку графических компонентов к полям
     класса.

#### Детальные инструкции

##### Model

Первым шагом предлагается переделать ваш текущий проект таким образом,
чтобы он располагался в подпапке `Model` и в его имя изменилось на
`name-surname-Model`. Для этого нужно выполнить следующие шаги:

  1. Переименовать вашу текущую директорию с исходниками в `Model` (скорее всего
     сейчас она называется `core`). Так, `kirill-kornyakov-lab2/core` была
     переименована в `kirill-kornyakov-lab2/Model`.
  1. Переместить `build.gradle` внутрь ее, после чего поправить пути в вашем
     `build.gradle`.
  1. Обновить общий файл с перечислением подпроектов, располагающийся по
     следующему пути: `agile-development-course/code/settings.gradle`. На этом
     этапе нужно будет обновить лишь первые 2 строки в вашей секции.
  1. Затем нужно будет проверить, что по-прежнему все работает, запустив
     следующие команды:
```bash
$ cd agile-development-course/code
$ gradle kirill-kornyakov-Model:check # change the path to yours
```
  1. Также на всякий случай стоит проверить, что работает генерация проекта для
     IDEA. Выполняем следующую команду (в той же директории `code`):
```bash
$ gradle kirill-kornyakov-Model:idea # change the path to yours
```
  1. После этого запускаем IDEA, и пробуем открыть проект в папке `code`, тот же
     файл `code.ipr`. Далее можно запустить уже свои тесты аналогично тому, как
     это делалось раньше для проекта-примера.
  1. Если построение и запуск тестов пройдет успешно, стоит сделать первый
     коммит в Git. Хочу обратить внимание, что предполагается, что вы работаете
     в той же ветке `lab2-mvvm-SOMETHING`, которую мы создали во время
     подготовительных работ. При желании уже можно отправить pull-request с
     целью тестирования его Travis.

##### View

 Теперь предстоит сверстать графическую форму в IDEA. Мы делаем это вперед
 `ViewModel` только затем, чтобы продумать интерфейс и логику взаимодействия
 с пользователем. Чтобы создать пустой проект, необходимо выполнить
 следующие шаги:

  1. Создать директорию `View` в своей подпапке.
  1. Создать набор вложенных директорий для исходников, подобно тому, как это
     сделано в вашей `Model` и проекте-примере:
     `code/kirill-kornyakov-lab2/View/src/main/ru/unn/agile/ComplexNumber/view/`.
  1. Положить в вашу папку `View` файл `build.gradle` следующего содержания:
```
sourceSets {
    main.java.srcDir 'src/main'
}
```
  1. Затем необходимо добавить этот файл в общий проект. Снова идем в
     глобальный `settings.gradle` и раскомментируем последние 2 строки в вашей
     секции, они как раз должны указывать на директорию View.
  1. Теперь можно сгенерировать проект для IDEA, чтобы открыть его в ней и
     приступить к проектированию формы. Выполняем следующую команду в консоли:
```
$ cd agile-development-course/code
$ gradle kirill-kornyakov-View:idea # change the path to yours
```
  1. Сгенерированный проект можно снова открыть в IDEA. Либо, если IDEA
     оставалась открытой, среда сама заметит изменения в файлах проекта и
     предложит перезагрузить проект. Нужно просто согласиться. Как результат
     вы должны увидеть в своей папке уже два подпроекта: `Model` и `View`.
  1. Теперь можно добавить пустую форму в ваш проект. Для этого в вашем
     проекте `View` раскройте папку `src` c исходниками до конца, и на вашем
     пакете (в проекте-примере это `ru.unn.agile.ComplexNumber.view`) нажмите
     правую кнопку мыши и выберите пункт _New > GUI Form_, дайте ей
     осмысленное имя и приступайте к проектированию.
  1. К сожалению тут вы наедине с собой, могу только посоветовать посмотреть
     следующую [видеолекцию][IDEA-GUI-Designer]. Также порекомендую сначала
     набрасывать компоненты `JPanel`, и только после них тесктовые поля и
     кнопки. Вы таким образом как-бы расчерчиваете саму форму.
  1. Чтобы запустить форму, нужно проделать следующее.
     - В окне дизайнера формы слева сверху располагается дерево компонентов
       вашей формы. Первым дочерним должен быть узел типа `JPanel`. Необходимо
       выбрать его, при этом чуть ниже должны появиться его свойства. Нужно
       выбрать первую строку _field name_ и дать ему какое-то имя, например
       `mainPanel`.
     - После этого можно нажать _F4_, чтобы перейти к коду формы. Также можно
       октрыть браузер проекта (дерево проектов и исходников), найти класс
       вашей формы и дважды щелкнуть по нему мышью.
     - Когда вы увидите код своей формы (он практически пуст), нужно будет
       сгенерировать метод `main` для нее. Для этого выбираем следующий пункт
       меню: _Code > Generate > Form main()_. Автоматически должен
       сгенерироваться метод.
     - Теперь можно запустить вашу форму также, как это делалось для
       проекта-примера. Выбираем в браузере проекта класс формы, нажимаем
       правую кнопку мыши и выбираем пунт _Run 'ClassName.main()'_.
  1. Таким образом предстоит сверстать форму, которая позволяла бы
     пользоваться вашим классом. Саму привязку класса делать не нужно,
     следует лишь зарезервировать поля.
  1. Результаты своей работы следует зафиксировать очередным коммитом в Git.
     Также можно сделать `push` в свой репозиторий на GitHub, чтобы Travis снова
     прогнал тесты.

##### ViewModel

Далее следует приступить к реализации `ViewModel`. По своей сути этот класс
является моделью вашей графической формы (что собственно следует из названия).
Таки образом, в нем следует завести поля, соответствующие графическим элементам
на вашем интерфейсе. Так, текстовые поля и метки отобразятся в обычные строки,
выпадающие списки можно "перевести" в поле типа `enum`. А нажатие на кнопку
можно обрабатывать как вызов обычного метода `ViewModel`.

Далее рассмотрим процесс реализации `ViewModel` по шагам:
  1. Аналогично тому, как создавались подпапки `Model` и `View`, нужно создать
     директорию `ViewModel` в папке со своим именем.
  1. В ней снова следует создать вложенную структуру папок для Java исходников и
     тестов, полностью аналогично тому, как это сделано в директории `Model`.
     Единственное отличие, что имя Java пакета должно быть `viewmodel`, то
     есть полное имя выглядит примерно следующим образом:
     `package ru.unn.agile.ComplexNumber.viewmodel;`.
  1. Затем следует создать `build.gradle` файл, и положить его в корень вашей
     директории `ViewModel`. Этот файл должен указывать системе сборки на
     исходники ваших классов и тестов, плюс указывать зависимость от вашего
     проекта `Model`. Вот примерный вид `build.gradle` файла:
```
dependencies {
    compile project(':kirill-kornyakov-Model')
}

sourceSets {
    main.java.srcDir 'src/main'
    test.java.srcDir 'src/test'
}
```
  1. Следующим шагом следует добавить созданный подпроект в систему сборки. Для
     этого снова открываем общий `settings.gradle` файл и раскомментируем
     последние две строки в вашей секции. Как результат, вы теперь можете
     сгенерировать проект IDEA:
```
$ cd agile-development-course/code
$ gradle kirill-kornyakov-ViewModel:idea
```
  1. Теперь можно открыть проект в IDEA и начать разработку согласно TDD
     практике. Стоит завести во `ViewModel` строковые поля, соответствующие
     входным агрументам, и метке статуса. Первым тестом может быть проверка на
     то, что выводятся корректные значения по умолчанию (например пустые строки
     для входных аргументов). Затем можно проверить (написать тест и реализовать
     код) при некорректном вводе от пользователя (например пустой ввод),
     выводится сообщение об ошибке.
  1. После этого уже можно переходить к полноценной реализации логики
     взаимодействия с пользователем. Пишутся тесты на все типичные сценарии
     взаимодействия, после чего эта логика реализуется по `ViewModel`. Стоит
     обратить особое внимание на то, что на этом этапе нет никакой необходимости
     использовать вашу реальную `View`.
  1. В качестве отдельного упражнения можно реализовать логику
     активации/деактивации контролов в зависимости от того, является ли
     корректным ввод. За инструкциями следует обратиться к проекту-примеру.
  1. Когда разработка `ViewModel` будет закончена, стоит убедиться что все
     созданные тесты успешно проходят (`gradle kirill-kornyakov-ViewModel:check`).
     Как обычно, рекомендуется сделать коммит и послать коды на тестирование Travis.

##### View

Последним шагом следует связать `View` и `ViewModel`. Сделать это относительно
просто:

  1. Первым делом нужно добавить зависимость `View` от `ViewModel`. Для этого
     открываем `build.gradle` в вашей директории `View` и добавляем информацию
     про зависимость:
```
dependencies {
    compile project(':kirill-kornyakov-ViewModel')
}

sourceSets {
    main.java.srcDir 'src/main'
}
```
  1. Затем перегенерируем IDEA проект (`gradle kirill-kornyakov-View:idea`) и
     снова открываем его в IDE.
  1. Далее следует завести поле типа `ViewModel` в вашем классе формы.
  1. Последнее что осталось сделать - это осуществить привязку полей реальной
     формы и ее модели, то есть `View` и `ViewModel`. Первым делом можно
     осуществить привязку нажатий кнопок к вызову методов `ViewModel`.
     В проекте-примере это сделано в конструкторе класса формы:
```
    btnCalc.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent actionEvent) {
            bind();
            Calculator.this.viewModel.calculate();
            backBind();
        }
    });
```
  1. Затем следует осуществить "binding" полей `ViewModel` к элементам
     графической формы. Для этого мы реализуем методы `bind` и `backBind`.
     Первый метод "забирает" значения с формы и копирует их во внутренние поля
     класса, метод `backBind` "записывает" обновившиеся значения обратно. Как
     говорилось на лекции, это наивный вариант привязки (binding), и некоторые
     технологии позволяют осуществлять ее автоматически. Вполне может быть, что
     IDEA позволяет настроить автоматическую привязку (там точно есть какие-то
     такие возможности). Поэтому кто разберется, просьба рассказать всем!

## Заключение

На этом выполнение лабораторной работы заканчивается. Стоит убедиться, что
тестами покрыты все случаи использования формы (в том числе некорректный ввод).
Также стоит просмотреть весь проект, вероятно возможно его упростить и
отрефакторить какие-то части.

После этого стоит положить все изменения в Git, и сделать pull request. В
комментарии просьба оставить упоминание о том, что работа готова к проверке.

<!-- LINKS -->

[settings.gradle]: <https://github.com/UNN-VMK-Software/agile-development-course/pull/63/files#diff-18>
[IDEA-GUI-Designer]: <http://www.jetbrains.com/idea/training/demos/GUI_Designer/GUI_Designer.html>
